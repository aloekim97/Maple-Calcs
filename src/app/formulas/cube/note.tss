import findComboProb, { CubeProbabilities, PotCalcResult } from "./comboprobability";
import cubeCombo, { Combination } from "./cubecombo";
import { WSE, WSEItemType } from "./potentialdropdown";

const CUBE_PROBABILITIES: { [key: string]: CubeProbabilities } = {
  black: { line1: 1.0, line2: 0.2, line3: 0.05 },
  red: { line1: 1.0, line2: 0.1, line3: 0.01 },
};

const CUBE_COST: { [key: string]: number } = {
  black: 22000000,
  red: 12000000,
};

const VALID_TARGETS_BY_POTENTIAL_TYPE: { [key: string]: number[] } = {
  stat: [24, 27, 30, 33, 36, 39],
  cooldown: [1, 2, 3, 4, 5, 6],
  critDamage: [8, 16, 24],
};

// Main function
export function potCalc(
  itemType: string,
  itemLevel: number,
  goal: any,
  cubeType: string
): PotCalcResult | undefined {
  console.log(goal)
  const tier = itemLevel > 150 ? 'high' : 'low';
  
  // Determine potential type and numeric goal
  let potentialType: string;
  let numericGoal: number;

  if (typeof goal === 'number') {
    // Simple numeric goal
    potentialType = 
      itemType === 'hat' ? (Math.random() < 0.5 ? 'stat' : 'cooldown') :
      itemType === 'glove' ? (Math.random() < 0.5 ? 'stat' : 'critDamage') :
      'stat';
    numericGoal = goal;
  } 
  else if ('att' in goal) {
    // WSE potential handling
    if (!['weapon', 'secondary', 'emblem'].includes(itemType)) {
      console.log('WSE potentials only available for weapon/secondary/emblem');
      return;
    }
    
    const wseItemType = itemType as WSEItemType;
    potentialType = 'wse';
    numericGoal = goal.att;
    
    const wseTargets = WSE[tier][wseItemType].att;
    if (!wseTargets.includes(numericGoal)) {
      console.log(`Invalid WSE goal. Valid ATT targets: ${wseTargets.join(', ')}`);
      return;
    }
  } 
  else {
    // Complex potential handling
    potentialType = goal.type;
    numericGoal = goal.value;
  }

  // Get cube cost and prime values
  const cost = CUBE_COST[cubeType];
  const { lPrime, uPrime } = itemLevel <= 150
    ? { lPrime: [12, 9], uPrime: [9, 6] }
    : { lPrime: [13, 10], uPrime: [10, 7] };

  // Get valid targets based on potential type
  const validTargets = potentialType === 'wse'
    ? WSE[tier][itemType as WSEItemType].att
    : VALID_TARGETS_BY_POTENTIAL_TYPE[potentialType] || [];

  if (!validTargets.includes(numericGoal)) {
    console.log(`Invalid goal. Valid targets: ${validTargets.join(', ')}`);
    return;
  }

  // Calculate combinations
  const goalIndex = validTargets.indexOf(numericGoal);
  const targetsFromGoal = validTargets.slice(goalIndex);
  const validCombinations: Combination[] = [];

  for (const target of targetsFromGoal) {
    validCombinations.push(...cubeCombo(target, lPrime, uPrime));
  }

  const averageTry = findComboProb(
    validCombinations,
    cubeType,
    itemType,
    potentialType
  );

  return {
    averageCost: (averageTry * cost).toLocaleString(),
    totalProbability: 1 / averageTry,
    averageTry,
    combinations: validCombinations,
  };
}


//
return (
    <div className="flex flex-col bg-white p-[16px] rounded-[16px] shadow-[0px_4px_8px_4px_rgba(0,0,0,0.1)] w-full gap-[16px]">
      {/* Header */}
      <div className="flex w-full justify-between">
        <div className="flex gap-[8px]">
          <Image src="image/Cube_Icon.svg" width={14} height={16} alt="star" />
          <h4>Potential Calculator</h4>
        </div>
        <Switch defaultChecked />
      </div>
      {/* Input fields */}
      <div className="flex flex-col gap-[16px]">
        <div className="flex w-full gap-[16px]">
          <div className="w-full">
            <p className="p3">Starting Tier</p>
            <Select
              value={inputs.cubeType}
              onValueChange={(value) =>
                setInputs((prev) => ({ ...prev, cubeType: value }))
              }
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Starting Tier" />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  <SelectLabel>Cube Type</SelectLabel>
                  <SelectItem value="rare">Rare</SelectItem>
                  <SelectItem value="epic">Epic</SelectItem>
                  <SelectItem value="unique">Unique</SelectItem>
                  <SelectItem value="legendary">Legendary</SelectItem>
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>
          <div className="w-full">
            <p className="p3">Desired Tier</p>
            <Select
              value={inputs.cubeType}
              onValueChange={(value) =>
                setInputs((prev) => ({ ...prev, cubeType: value }))
              }
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Desired Tier" />
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  <SelectLabel>Cube Type</SelectLabel>
                  <SelectItem value="rare">Rare</SelectItem>
                  <SelectItem value="epic">Epic</SelectItem>
                  <SelectItem value="unique">Unique</SelectItem>
                  <SelectItem value="legendary">Legendary</SelectItem>
                </SelectGroup>
              </SelectContent>
            </Select>
          </div>
        </div>
        <div>
          <p className="p3">Cube Type</p>
          <Select
            value={inputs.cubeType}
            onValueChange={(value) =>
              setInputs((prev) => ({ ...prev, cubeType: value }))
            }
          >
            <SelectTrigger className="w-full">
              <SelectValue placeholder="Select cube type..." />
            </SelectTrigger>
            <SelectContent>
              <SelectGroup>
                <SelectLabel>Cube Type</SelectLabel>
                <SelectItem value="black">Black Cube</SelectItem>
                <SelectItem value="red">Red Cube</SelectItem>
              </SelectGroup>
            </SelectContent>
          </Select>
        </div>
        <div>
          <p className="p3">Line 1</p>
          <Select
            value={lines.first}
            onValueChange={(value) =>
              setInputs((prev) => ({ ...prev, cubeType: value }))
            }
          >
            <SelectTrigger className="w-full">
              <SelectValue placeholder="Select cube type..." />
            </SelectTrigger>
            <SelectContent>
              <SelectGroup>
                <SelectLabel>Line 1</SelectLabel>
                {Object.entries(goalOptions).map(([label, value]) => (
                  <SelectLabel key={label} value={JSON.stringify(value)}>
                    {label}
                  </SelectLabel>
                ))}

              </SelectGroup>
            </SelectContent>
          </Select>
        </div>
        <div>
          <p className="p3">Line 2</p>
          <Select
            value={inputs.cubeType}
            onValueChange={(value) =>
              setInputs((prev) => ({ ...prev, cubeType: value }))
            }
          >
            <SelectTrigger className="w-full">
              <SelectValue placeholder="Select cube type..." />
            </SelectTrigger>
            <SelectContent>
              <SelectGroup>
                <SelectLabel>Cube Type</SelectLabel>
                <SelectItem value="black">Black Cube</SelectItem>
                <SelectItem value="red">Red Cube</SelectItem>
              </SelectGroup>
            </SelectContent>
          </Select>
        </div>
        <div>
          <p className="p3">Line 3</p>
          <Select
            value={inputs.cubeType}
            onValueChange={(value) =>
              setInputs((prev) => ({ ...prev, cubeType: value }))
            }
          >
            <SelectTrigger className="w-full">
              <SelectValue placeholder="Select cube type..." />
            </SelectTrigger>
            <SelectContent>
              <SelectGroup>
                <SelectLabel>Line 3</SelectLabel>
                <SelectItem value="black">Black Cube</SelectItem>
                <SelectItem value="red">Red Cube</SelectItem>
              </SelectGroup>
            </SelectContent>
          </Select>
        </div>

        {results && (
          <div className="mt-6 space-y-4">
            <h3 className="font-medium text-lg">Potential Results</h3>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <p>
                  <strong>Average Cost:</strong>
                </p>
                <p>{results.averageCost} mesos</p>
              </div>
              <div>
                <p>
                  <strong>Success Chance:</strong>
                </p>
                <p>{(results.totalProbability * 100).toFixed(6)}%</p>
              </div>
              <div>
                <p>
                  <strong>Average Attempts:</strong>
                </p>
                <p>{results.averageTry.toFixed(1)}</p>
              </div>
            </div>

            <div className="mt-4">
              <h3 className="font-medium">Valid Combinations</h3>
              <div className="max-h-60 overflow-y-auto mt-2 border rounded p-2">
                {results.combinations.map((combo, i) => (
                  <div key={i} className="py-1 border-b last:border-b-0">
                    Line 1: {combo.line1}, Line 2: {combo.line2}, Line 3:{' '}
                    {combo.line3}
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


export default function findComboProb(
  combinations: Combination[],
  cubeType: string,
  itemType: string
): number {
  console.log('[findComboProb] Starting calculation - Showing first combination only');
  
  const cubeProb = CUBE_PROBABILITIES[cubeType];
  const itemProb = ITEM_PROBABILITIES[itemType];

  if (!itemProb) {
    console.error(`No probability data found for item type: ${itemType}`);
    return Infinity;
  }

  function classifyLine(line: string): { type: string; value: number } {
    const match = line.match(/(\d+)% ([LU])/);
    if (!match) {
      return { type: 'unknown', value: 0 };
    }
    const value = parseInt(match[1]);
    const lineType = match[2];

    if (lineType === 'L') {
      if (statValues.statPrime.includes(value)) return { type: 'statPrime', value };
      if (statValues.allPrime.includes(value)) return { type: 'allPrime', value };
    } else {
      if (statValues.statNonPrime.includes(value)) return { type: 'statNonPrime', value };
      if (statValues.allNonPrime.includes(value)) return { type: 'allNonPrime', value };
    }

    // Handle special cases
    if (line.includes('Cooldown')) return { type: 'cooldown', value };
    if (line.includes('Critical Damage')) return { type: 'critdamage', value };
    if (line.includes('Meso')) return { type: 'dropmeso', value };

    return { type: 'unknown', value };
  }

  function getLineProbability(lineInfo: { type: string; value: number }, lineNumber: number): number {
    const cubeLineProb = cubeProb[`line${lineNumber}` as keyof CubeProbabilities];
    
    // Handle special numeric cases
    if (lineInfo.type === 'cooldown' || lineInfo.type === 'critdamage' || lineInfo.type === 'dropmeso') {
      const probTable = itemProb[lineInfo.type as keyof typeof itemProb];
      if (probTable && typeof probTable === 'object') {
        const numericTable = probTable as { [key: number]: number };
        if (lineInfo.value in numericTable) {
          return cubeLineProb * (numericTable[lineInfo.value] / 100);
        }
      }
      return 0;
    }
    
    // Handle stat probability cases
    if (itemProb.stat) {
      const statKey = lineInfo.type as keyof ProbabilityTiers;
      if (statKey in itemProb.stat) {
        return cubeLineProb * (itemProb.stat[statKey] / 100);
      }
    }

    return 0;
  }

  // Only process the first combination
  for (let i = 0; i < Math.min(2, combinations.length); i++) {
    const combo = combinations[i];
    console.log(`\n===== COMBINATION ${i+1} ANALYSIS =====`);
    console.log('Original Lines:', combo.lines);
    
    const line1Info = classifyLine(combo.lines[0]);
    const line2Info = classifyLine(combo.lines[1]);
    const line3Info = classifyLine(combo.lines[2]);
    
    console.log('\nClassified Lines:');
    console.log('Line 1:', line1Info);
    console.log('Line 2:', line2Info);
    console.log('Line 3:', line3Info);

    const line1Prob = getLineProbability(line1Info, 1);
    const line2Prob = getLineProbability(line2Info, 2);
    const line3Prob = getLineProbability(line3Info, 3);

    console.log('\nLine Probabilities:');
    console.log('Line 1:', `${(line1Prob * 100).toFixed(2)}%`);
    console.log('Line 2:', `${(line2Prob * 100).toFixed(2)}%`);
    console.log('Line 3:', `${(line3Prob * 100).toFixed(2)}%`);

    const comboProb = line1Prob * line2Prob * line3Prob;
    console.log('\nCombination Probability:', `${(comboProb * 100).toFixed(6)}%`);
    console.log('Cube Cost:', CUBE_COST[cubeType].toLocaleString());
  }

  if (combinations.length === 0) {
    console.log('No combinations available to analyze');
  } else if (combinations.length === 1) {
    console.log('\n(Only 1 combination available)');
  }

  // Still return the full calculation (but we only logged the first combo)
  let totalProbability = 0;
  combinations.forEach(combo => {
    const line1Info = classifyLine(combo.lines[0]);
    const line2Info = classifyLine(combo.lines[1]);
    const line3Info = classifyLine(combo.lines[2]);
    totalProbability += getLineProbability(line1Info, 1) * 
                       getLineProbability(line2Info, 2) * 
                       getLineProbability(line3Info, 3);
  });

  return totalProbability > 0 ? 1 / totalProbability : Infinity;
}