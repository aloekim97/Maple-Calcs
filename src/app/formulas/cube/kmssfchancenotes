function calculateStarForceStats(startStar, endStar, starCatch = false, safeguard = false, reducedBooms = false) {
  const rates = {
    initial: {
      0: [95, 5, 0],
      1: [90, 10, 0],
      2: [85, 15, 0],
      3: [85, 15, 0],
      4: [80, 20, 0],
      5: [75, 25, 0],
      6: [70, 30, 0],
      7: [65, 35, 0],
      8: [60, 40, 0],
      9: [55, 45, 0],
      10: [50, 50, 0],
      11: [45, 55, 0],
    },
    mid: {
      12: [40, 60, 0],
      13: [35, 65, 0],
      14: [30, 70, 0],
    },
    funzone: {
      15: [30, 67.9, 2.1],
      16: [30, 67.9, 2.1],
      17: [15, 78.2, 6.8],
      18: [15, 78.2, 6.8],
      19: [15, 76.5, 8.5],
      20: [30, 59.5, 10.5],
      21: [15, 72.5, 12.5],
      22: [15, 68, 17],
      23: [10, 72, 18],
      24: [10, 72, 18],
      25: [10, 72, 18],
      26: [7, 74.4, 18.6],
      27: [5, 76, 19],
      28: [3, 77.6, 19.4],
      29: [1, 79.2, 19.8],
    },
  };

  // Validate input
  if (startStar < 0 || startStar > 29 || endStar < 0 || endStar > 29 || startStar >= endStar) {
    throw new Error("Invalid star range");
  }

  // Initialize variables
  let currentStar = startStar;
  let totalAttempts = 0;
  let totalBooms = 0;
  const starAttempts = {}; // Stores attempts needed for each star

  while (currentStar < endStar) {
    // Determine which rate table to use
    let rateTable;
    if (currentStar <= 11) rateTable = rates.initial;
    else if (currentStar <= 14) rateTable = rates.mid;
    else rateTable = rates.funzone;

    // Get current rates
    let [success, fail, boom] = rateTable[currentStar];
    
    // Apply modifiers
    if (starCatch && boom > 0) {
      boom /= 2;
      fail += (rateTable[currentStar][2] - boom);
    }
    
    if (reducedBooms && boom > 0) {
      boom *= 0.7;
      fail += (rateTable[currentStar][2] - boom);
    }

    // Normalize rates
    const total = success + fail + boom;
    success = success / total;
    fail = fail / total;
    boom = boom / total;

    // Calculate expected attempts for this star
    const attemptsForThisStar = 1 / success;
    
    // Calculate boom probability per attempt at this star
    const boomProbabilityPerAttempt = boom;
    
    // Expected booms while attempting this star
    const expectedBoomsAtThisStar = attemptsForThisStar * boomProbabilityPerAttempt;
    
    // If we boom, we have to redo from 15, so we need to account for that
    if (boom > 0 && currentStar > 15) {
      const recoveryAttempts = calculateRecoveryAttempts(15, currentStar, starCatch, safeguard, reducedBooms);
      totalAttempts += attemptsForThisStar + (expectedBoomsAtThisStar * recoveryAttempts.attempts);
      totalBooms += expectedBoomsAtThisStar + (expectedBoomsAtThisStar * recoveryAttempts.booms);
    } else {
      // No boom risk or already at/above 15 (booming doesn't set us back further)
      totalAttempts += attemptsForThisStar;
      totalBooms += expectedBoomsAtThisStar;
    }

    starAttempts[currentStar] = {
      attempts: attemptsForThisStar,
      booms: expectedBoomsAtThisStar
    };

    currentStar++;
  }

  return {
    startStar,
    endStar,
    totalAttempts,
    totalBooms,
    attemptsPerBoom: totalBooms > 0 ? totalAttempts / totalBooms : Infinity,
    starAttempts
  };

  // Helper function to calculate attempts needed to recover after a boom
  function calculateRecoveryAttempts(from, to, starCatch, safeguard, reducedBooms) {
    let attempts = 0;
    let booms = 0;
    
    for (let star = from; star < to; star++) {
      let rateTable;
      if (star <= 11) rateTable = rates.initial;
      else if (star <= 14) rateTable = rates.mid;
      else rateTable = rates.funzone;

      let [success, fail, boom] = rateTable[star];
      
      if (starCatch && boom > 0) {
        boom /= 2;
        fail += (rateTable[star][2] - boom);
      }
      
      if (reducedBooms && boom > 0) {
        boom *= 0.7;
        fail += (rateTable[star][2] - boom);
      }

      const total = success + fail + boom;
      success = success / total;
      boom = boom / total;

      const attemptsForThisStar = 1 / success;
      const expectedBoomsAtThisStar = attemptsForThisStar * boom;

      attempts += attemptsForThisStar;
      booms += expectedBoomsAtThisStar;

      // If we boom during recovery, we have to restart recovery from 15 again
      if (boom > 0 && star > 15) {
        const recovery = calculateRecoveryAttempts(15, star, starCatch, safeguard, reducedBooms);
        attempts += expectedBoomsAtThisStar * recovery.attempts;
        booms += expectedBoomsAtThisStar * recovery.booms;
      }
    }
    
    return { attempts, booms };
  }
}

// Example usage:
const stats = calculateStarForceStats(0, 23, false, false, false);
console.log(`Estimated to reach star ${stats.endStar} from ${stats.startStar}:`);
console.log(`- Total attempts: ${stats.totalAttempts.toFixed(2)}`);
console.log(`- Total booms: ${stats.totalBooms.toFixed(2)}`);
console.log(`- Attempts per boom: ${stats.attemptsPerBoom.toFixed(2)}`);
console.log("Per-star breakdown:", stats.starAttempts);


const starMultipliers: { [key: number]: number } = {
  17: 1.31766055,
  18: 2.8571348,
  19: 4.44443047,
  21: 1.59999951,
};

if (currentStar < 10) {
  baseCost = (100 * Math.pow(adjustedLevel, 3) * (currentStar + 1)) / 2500 + 10;
} else if (currentStar === 10) {
  baseCost = (100 * Math.pow(adjustedLevel, 3) * Math.pow(currentStar + 1, 2.7)) / 40000 + 10;
} else if (currentStar === 11) {
  baseCost = (100 * Math.pow(adjustedLevel, 3) * Math.pow(currentStar + 1, 2.7)) / 22000 + 10;
} else if (currentStar === 12) {
  baseCost = (100 * Math.pow(adjustedLevel, 3) * Math.pow(currentStar + 1, 2.7)) / 15000 + 10;
} else if (currentStar === 13) {
  baseCost = (100 * Math.pow(adjustedLevel, 3) * Math.pow(currentStar + 1, 2.7)) / 11000 + 10;
} else if (currentStar === 14) {
  baseCost = (100 * Math.pow(adjustedLevel, 3) * Math.pow(currentStar + 1, 2.7)) / 7500 + 10;
} else {
  baseCost = (100 * Math.pow(adjustedLevel, 3) * Math.pow(currentStar + 1, 2.7)) / 20000 + 10;
}


export function calculateMedianCost(totalExpectedCost: number, stdDev: number) {
  if (stdDev === 0) return totalExpectedCost; // deterministic case
  const cv = stdDev / totalExpectedCost; // coefficient of variation
  const adjustment = Math.sqrt(1 + cv * cv);
  return totalExpectedCost / adjustment;
}